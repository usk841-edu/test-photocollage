<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>A4 Photo Tiler Editor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  font-family: system-ui, -apple-system, sans-serif;
  padding: 16px;
}
canvas {
  width: 100%;
  max-width: 600px;
  border: 1px solid #ccc;
  touch-action: none;
  margin-top: 12px;
}
.controls {
  margin-top: 12px;
}
button {
  margin-top: 12px;
  padding: 10px 16px;
  font-size: 16px;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/heic2any/dist/heic2any.min.js"></script>
</head>
<body>

<h2>A4 3×7 写真タイル（高速版）</h2>

<input type="file" id="photos" accept="image/*,.heic" multiple>
<canvas id="canvas"></canvas>

<div class="controls">
  <label>
    拡大縮小：
    <input type="range" id="scale" min="0.5" max="2" step="0.01" value="1">
  </label>
  <br>
  <label>
    <input type="checkbox" id="rotate">
    90度回転
  </label>
  <br><br>
  <label>
    保存形式：
    <select id="format">
      <option value="image/jpeg" selected>JPG</option>
      <option value="image/png">PNG</option>
    </select>
  </label>
</div>

<button id="download">この内容でダウンロード</button>

<script>
(() => {

const COLS = 3;
const ROWS = 7;
const A4_WIDTH = 2480;
const A4_HEIGHT = 3508;
const MAX_EDGE = 1000; // ★ 長辺1000pxに制限

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = A4_WIDTH;
canvas.height = A4_HEIGHT;

const input = document.getElementById('photos');
const scaleInput = document.getElementById('scale');
const rotateInput = document.getElementById('rotate');
const formatSelect = document.getElementById('format');

let tiles = [];
let activeIndex = null;
let dragStart = null;

input.addEventListener('change', loadPhotos);

scaleInput.addEventListener('input', () => {
  if (activeIndex !== null) {
    tiles[activeIndex].scale = +scaleInput.value;
    draw();
  }
});

rotateInput.addEventListener('change', () => {
  if (activeIndex !== null) {
    tiles[activeIndex].rotate = rotateInput.checked;
    draw();
  }
});

canvas.addEventListener('pointerdown', e => {
  const pos = getCanvasPos(e);
  activeIndex = hitTest(pos.x, pos.y);
  if (activeIndex !== null) {
    const t = tiles[activeIndex];
    scaleInput.value = t.scale;
    rotateInput.checked = t.rotate;
    dragStart = pos;
  }
});

canvas.addEventListener('pointermove', e => {
  if (dragStart && activeIndex !== null) {
    const pos = getCanvasPos(e);
    tiles[activeIndex].offsetX += pos.x - dragStart.x;
    tiles[activeIndex].offsetY += pos.y - dragStart.y;
    dragStart = pos;
    draw();
  }
});

canvas.addEventListener('pointerup', () => dragStart = null);
canvas.addEventListener('pointerleave', () => dragStart = null);

document.getElementById('download').addEventListener('click', () => {
  const mime = formatSelect.value;
  const ext = mime === 'image/png' ? 'png' : 'jpg';

  const a = document.createElement('a');
  a.download = `a4_3x7.${ext}`;
  a.href = mime === 'image/jpeg'
    ? canvas.toDataURL(mime, 0.92)
    : canvas.toDataURL(mime);
  a.click();
});

async function loadPhotos() {
  tiles = [];
  const files = Array.from(input.files).slice(0, COLS * ROWS);

  // ★ 並列処理
  const images = await Promise.all(
    files.map(file => loadImage(file))
  );

  tiles = images.map(img => {
    const autoRotate = img.height > img.width; // ★ 縦長は自動回転
    return {
      img,
      scale: 1,
      offsetX: 0,
      offsetY: 0,
      rotate: autoRotate
    };
  });

  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const tileW = A4_WIDTH / COLS;
  const tileH = A4_HEIGHT / ROWS;

  tiles.forEach((t, i) => {

    const col = i % COLS;
    const row = Math.floor(i / COLS);

    const logicalW = t.rotate ? t.img.height : t.img.width;
    const logicalH = t.rotate ? t.img.width : t.img.height;

    const baseScale = Math.max(
      tileW / logicalW,
      tileH / logicalH
    );

    const scale = baseScale * t.scale;

    const drawW = t.img.width * scale;
    const drawH = t.img.height * scale;

    const cx = col * tileW + tileW / 2 + t.offsetX;
    const cy = row * tileH + tileH / 2 + t.offsetY;

    ctx.save();
    ctx.beginPath();
    ctx.rect(col * tileW, row * tileH, tileW, tileH);
    ctx.clip();

    ctx.translate(cx, cy);
    if (t.rotate) ctx.rotate(Math.PI / 2);

    ctx.drawImage(t.img, -drawW / 2, -drawH / 2, drawW, drawH);
    ctx.restore();

    if (i === activeIndex) {
      ctx.strokeStyle = '#007aff';
      ctx.lineWidth = 6;
      ctx.strokeRect(col * tileW, row * tileH, tileW, tileH);
    }
  });
}

function hitTest(x, y) {
  const tileW = A4_WIDTH / COLS;
  const tileH = A4_HEIGHT / ROWS;
  const col = Math.floor(x / tileW);
  const row = Math.floor(y / tileH);
  const index = row * COLS + col;
  return tiles[index] ? index : null;
}

function getCanvasPos(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * (canvas.width / rect.width),
    y: (e.clientY - rect.top) * (canvas.height / rect.height)
  };
}

async function loadImage(file) {
  let blob = file;

  if (
    file.type === 'image/heic' ||
    file.type === 'image/heif' ||
    file.name.toLowerCase().endsWith('.heic')
  ) {
    const result = await heic2any({
      blob: file,
      toType: 'image/jpeg',
      quality: 0.9
    });
    blob = Array.isArray(result) ? result[0] : result;
  }

  const img = await new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => resolve(image);
    image.onerror = reject;
    image.src = URL.createObjectURL(blob);
  });

  // ★ 長辺1000pxに縮小
  const longEdge = Math.max(img.width, img.height);

  if (longEdge > MAX_EDGE) {
    const scale = MAX_EDGE / longEdge;

    const resizeCanvas = document.createElement("canvas");
    resizeCanvas.width = img.width * scale;
    resizeCanvas.height = img.height * scale;

    const rctx = resizeCanvas.getContext("2d");
    rctx.drawImage(img, 0, 0, resizeCanvas.width, resizeCanvas.height);

    return await new Promise(resolve => {
      const resized = new Image();
      resized.onload = () => resolve(resized);
      resized.src = resizeCanvas.toDataURL("image/jpeg", 0.9);
    });
  }

  return img;
}

})();
</script>

</body>
</html>
