<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>A4 Photo Tiler Editor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body {
    font-family: system-ui, -apple-system, sans-serif;
    padding: 16px;
  }
  canvas {
    width: 100%;
    max-width: 600px;
    border: 1px solid #ccc;
    touch-action: none;
    margin-top: 12px;
  }
  .controls {
    margin-top: 12px;
  }
</style>

<!-- HEIC対応ライブラリ -->
<script src="https://cdn.jsdelivr.net/npm/heic2any/dist/heic2any.min.js"></script>
</head>
<body>

<h2>A4 3×7 写真タイル（編集可）</h2>

<input type="file" id="photos" accept="image/*,.heic" multiple>

<canvas id="canvas"></canvas>

<div class="controls">
  <label>
    拡大縮小：
    <input type="range" id="scale" min="0.5" max="2" step="0.01" value="1">
  </label>
  <br>
  <label>
    <input type="checkbox" id="rotate">
    90度回転
  </label>
  <br><br>
  <label>
    保存形式：
    <select id="format">
      <option value="image/jpeg" selected>JPG</option>
      <option value="image/png">PNG</option>
    </select>
  </label>
</div>

<button id="download">この内容でダウンロード</button>

<script>
(() => {
  const COLS = 3;
  const ROWS = 7;
  const A4_WIDTH = 2480;
  const A4_HEIGHT = 3508;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = A4_WIDTH;
  canvas.height = A4_HEIGHT;

  const input = document.getElementById('photos');
  const scaleInput = document.getElementById('scale');
  const rotateInput = document.getElementById('rotate');
  const formatSelect = document.getElementById('format');

  let tiles = [];
  let activeIndex = null;
  let dragStart = null;

  input.addEventListener('change', loadPhotos);

  scaleInput.addEventListener('input', () => {
    if (activeIndex !== null) {
      tiles[activeIndex].scale = +scaleInput.value;
      draw();
    }
  });

  rotateInput.addEventListener('change', () => {
    if (activeIndex !== null) {
      tiles[activeIndex].rotate = rotateInput.checked;
      draw();
    }
  });

  canvas.addEventListener('pointerdown', e => {
    const { offsetX, offsetY } = getCanvasPos(e);
    activeIndex = hitTest(offsetX, offsetY);
    if (activeIndex !== null) {
      const t = tiles[activeIndex];
      scaleInput.value = t.scale;
      rotateInput.checked = t.rotate;
      dragStart = { x: offsetX, y: offsetY };
    }
  });

  canvas.addEventListener('pointermove', e => {
    if (dragStart && activeIndex !== null) {
      const { offsetX, offsetY } = getCanvasPos(e);
      tiles[activeIndex].offsetX += offsetX - dragStart.x;
      tiles[activeIndex].offsetY += offsetY - dragStart.y;
      dragStart = { x: offsetX, y: offsetY };
      draw();
    }
  });

  canvas.addEventListener('pointerup', () => dragStart = null);
  canvas.addEventListener('pointerleave', () => dragStart = null);

  document.getElementById('download').addEventListener('click', () => {
    const mime = formatSelect.value;
    const ext = mime === 'image/png' ? 'png' : 'jpg';

    const a = document.createElement('a');
    a.download = `a4_3x7.${ext}`;
    a.href = mime === 'image/jpeg'
      ? canvas.toDataURL(mime, 0.92)
      : canvas.toDataURL(mime);
    a.click();
  });

  async function loadPhotos() {
    tiles = [];
    const files = Array.from(input.files).slice(0, COLS * ROWS);
    for (const file of files) {
      const img = await loadImage(file);
      tiles.push({
        img,
        scale: 1,
        offsetX: 0,
        offsetY: 0,
        rotate: false
      });
    }
    draw();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const tileW = A4_WIDTH / COLS;
    const tileH = A4_HEIGHT / ROWS;

    tiles.forEach((t, i) => {
      const col = i % COLS;
      const row = Math.floor(i / COLS);

      const baseScale = Math.max(
        tileW / (t.rotate ? t.img.height : t.img.width),
        tileH / (t.rotate ? t.img.width : t.img.height)
      );

      const scale = baseScale * t.scale;
      const drawW = t.img.width * scale;
      const drawH = t.img.height * scale;

      const cx = col * tileW + tileW / 2 + t.offsetX;
      const cy = row * tileH + tileH / 2 + t.offsetY;

      ctx.save();
      ctx.beginPath();
      ctx.rect(col * tileW, row * tileH, tileW, tileH);
      ctx.clip();

      ctx.translate(cx, cy);
      if (t.rotate) ctx.rotate(Math.PI / 2);
      ctx.drawImage(t.img, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.restore();

      if (i === activeIndex) {
        ctx.strokeStyle = '#007aff';
        ctx.lineWidth = 6;
        ctx.strokeRect(col * tileW, row * tileH, tileW, tileH);
      }
    });
  }

  function hitTest(x, y) {
    const tileW = A4_WIDTH / COLS;
    const tileH = A4_HEIGHT / ROWS;
    const col = Math.floor(x / tileW);
    const row = Math.floor(y / tileH);
    const index = row * COLS + col;
    return tiles[index] ? index : null;
  }

  function getCanvasPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      offsetX: (e.clientX - rect.left) * (canvas.width / rect.width),
      offsetY: (e.clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  async function loadImage(file) {
    let blob = file;

    // HEIC → JPEG に変換
    if (file.type === 'image/heic' || file.name.toLowerCase().endsWith('.heic')) {
      blob = await heic2any({
        blob: file,
        toType: 'image/jpeg',
        quality: 0.95
      });
    }

    return new Promise(resolve => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.src = URL.createObjectURL(blob);
    });
  }
})();
</script>

</body>
</html>
